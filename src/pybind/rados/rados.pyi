import threading
from typing import List, Any, Optional, Tuple, Dict

LIBRADOS_OP_FLAG_EXCL = ...
LIBRADOS_OP_FLAG_FAILOK = ...
LIBRADOS_OP_FLAG_FADVISE_RANDOM = ...
LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL = ...
LIBRADOS_OP_FLAG_FADVISE_WILLNEED = ...
LIBRADOS_OP_FLAG_FADVISE_DONTNEED = ...
LIBRADOS_OP_FLAG_FADVISE_NOCACHE = ...

LIBRADOS_SNAP_HEAD = ...

LIBRADOS_OPERATION_NOFLAG = ...
LIBRADOS_OPERATION_BALANCE_READS = ...
LIBRADOS_OPERATION_LOCALIZE_READS = ...
LIBRADOS_OPERATION_ORDER_READS_WRITES = ...
LIBRADOS_OPERATION_IGNORE_CACHE = ...
LIBRADOS_OPERATION_SKIPRWLOCKS = ...
LIBRADOS_OPERATION_IGNORE_OVERLAY = ...

LIBRADOS_ALL_NSPACES = ...

LIBRADOS_CREATE_EXCLUSIVE = ...
LIBRADOS_CREATE_IDEMPOTENT = ...

ANONYMOUS_AUID = 0xffffffffffffffff
ADMIN_AUID = 0

class Error(Exception):
     def __init__(self, message, errno=None):
         self.errno = errno

class InvalidArgumentError(Error): pass
class OSError(Error): pass
class InterruptedOrTimeoutError(OSError): pass
class PermissionError(OSError): pass
class PermissionDeniedError(OSError): pass
class ObjectNotFound(OSError): pass
class NoData(OSError): pass
class ObjectExists(OSError): pass
class ObjectBusy(OSError): pass
class IOError(OSError): pass
class NoSpace(OSError): pass
class RadosStateError(Error): pass
class IoctxStateError(Error): pass
class ObjectStateError(Error): pass
class LogicError(Error): pass
class TimedOut(OSError): pass

class Version(object):
    def __init__(self, major, minor, extra):
        self.major = major
        self.minor = minor
        self.extra = extra


class Rados(object):
    def __init__(self, rados_id=None, name=None, clustername=None,
                conf_defaults=None, conffile=None, conf=None, flags=0,
                context=None):
        self.monitor_callback = None
        self.monitor_callback2 = None
        self.parsed_args = []  # type: List[Any]
        self.conf_defaults = conf_defaults
        self.conffile = conffile
        self.rados_id = rados_id
        self.cluster = ...
        self.state = ...

    def require_state(self, *args):...
    def shutdown(self):...
    def __enter__(self):...
    def __exit__(self, type_, value, traceback):...
    def version(self) -> Tuple[int, int, int]:...
    def conf_read_file(self, path=None):...
    def conf_parse_argv(self, args):...
    def conf_parse_env(self, var='CEPH_ARGS'):...
    def conf_get(self, option) -> str:...
    def conf_set(self, option, val):...
    def ping_monitor(self, mon_id) -> str:...
    def connect(self, timeout=0):...
    def get_instance_id(self):...
    def get_cluster_stats(self) -> Dict[str, int]:...
    def pool_exists(self, pool_name) -> bool:...
    def pool_lookup(self, pool_name) -> Optional[int]:...
    def pool_reverse_lookup(self, pool_id) -> Optional[str]:...
    def create_pool(self, pool_name, crush_rule=None):...
    def get_pool_base_tier(self, pool_id) -> int:...
    def delete_pool(self, pool_name):...
    def get_inconsistent_pgs(self, pool_id) -> list:...
    def list_pools(self) -> List[str]:...
    def get_fsid(self) -> str:...
    def open_ioctx(self, ioctx_name) -> Ioctx:...
    def open_ioctx2(self, pool_id:int) -> Ioctx:...
    def mon_command(self, cmd, inbuf, timeout=0, target=None):...
    def osd_command(self, osdid, cmd, inbuf, timeout=0):...
    def mgr_command(self, cmd, inbuf, timeout=0):...
    def pg_command(self, pgid, cmd, inbuf, timeout=0):...
    def wait_for_latest_osdmap(self):...
    def blacklist_add(self, client_address, expire_seconds=0):...
    def monitor_log(self, level, callback, arg):...
    def monitor_log2(self, level, callback, arg):...
    def service_daemon_register(self, service, daemon, metadata):...
    def service_daemon_update(self, status):...

class OmapIterator(object):
    def __iter__(self):...
    def __next__(self):...

class ObjectIterator(object):
    def __init__(self, ioctx: Ioctx):
        self.ioctx = ioctx
    def __iter__(self):...
    def __next__(self):...

class XattrIterator(object):
    def __iter__(self):...
    def __next__(self):...

class SnapIterator(object):
    def __iter__(self):...
    def __next__(self):...


class Snap(object):
    def __init__(self, ioctx: Ioctx, name, snap_id):
        self.ioctx = ioctx
        self.name = name
        self.snap_id = snap_id
    def get_timestamp(self):...

class Completion(object):
    def __init__(self, ioctx: Ioctx, oncomplete, onsafe):
        self.oncomplete = oncomplete
        self.onsafe = onsafe
        self.ioctx = ioctx

    def is_safe(self):...
    def is_complete(self):...
    def wait_for_safe(self):...
    def wait_for_complete(self):...
    def wait_for_safe_and_cb(self):...
    def wait_for_complete_and_cb(self):...
    def get_return_value(self):...

class OpCtx(object):
    def __enter__(self):...
    def __exit__(self, type, msg, traceback):...

class WriteOp(object):
    def create(self):...
    def release(self):...
    def new(self, exclusive=None):...
    def remove(self):...
    def set_flags(self, flags=LIBRADOS_OPERATION_NOFLAG):...
    def append(self, to_write):...
    def write_full(self, to_write):...
    def write(self, to_write, offset=0):...
    def assert_version(self, version):...
    def zero(self, offset, length):...
    def truncate(self, offset):...

class WriteOpCtx(WriteOp, OpCtx): pass

class ReadOp(object):
    def create(self):...
    def release(self):...
    def set_flags(self, flags=LIBRADOS_OPERATION_NOFLAG):...

class ReadOpCtx(ReadOp, OpCtx): pass

class Ioctx(object):
    def __init__(self, name: str):
        self.name = name
        self.state = "open"

        self.locator_key = ""
        self.nspace = ""
        self.lock = threading.Lock()
        self.safe_completions = []  # type: List[Any]
        self.complete_completions = []  # type: List[Any]

    def __enter__(self):...
    def __exit__(self, type_, value, traceback):...
    def aio_stat(self, object_name, oncomplete):...
    def aio_write(self, object_name, to_write, offset=0,
                  oncomplete=None, onsafe=None):...
    def aio_write_full(self, object_name, to_write,
                       oncomplete=None, onsafe=None):...
    def aio_append(self, object_name, to_append, oncomplete=None, onsafe=None):...
    def aio_flush(self):...
    def aio_read(self, object_name, length, offset, oncomplete):...
    def aio_execute(self, object_name, cls, method, data,
                    length=8192, oncomplete=None, onsafe=None):...
    def aio_remove(self, object_name, oncomplete=None, onsafe=None):...
    def require_ioctx_open(self):...
    def set_locator_key(self, loc_key):...
    def get_locator_key(self):...
    def set_read(self, snap_id):...
    def set_namespace(self, nspace):...
    def get_namespace(self):...
    def close(self):...
    def write(self, key, data, offset=0):...
    def write_full(self, key, data):...
    def append(self, key, data):...
    def read(self, key, length=8192, offset=0):...
    def execute(self, key, cls, method, data, length=8192):...
    def get_stats(self):...
    def remove_object(self, key):...
    def trunc(self, key, size):...
    def stat(self, key):...
    def get_xattr(self, key, xattr_name):...
    def get_xattrs(self, oid):...
    def set_xattr(self, key, xattr_name, xattr_value):...
    def rm_xattr(self, key, xattr_name):...
    def notify(self, obj, msg='', timeout_ms=5000):...
    def list_objects(self):...
    def list_snaps(self):...
    def create_snap(self, snap_name):...
    def remove_snap(self, snap_name):...
    def lookup_snap(self, snap_name):...
    def snap_rollback(self, oid, snap_name):...
    def create_self_managed_snap(self):...
    def remove_self_managed_snap(self, snap_id):...
    def set_self_managed_snap_write(self, snaps):...
    def rollback_self_managed_snap(self, oid, snap_id):...
    def get_last_version(self):...
    def create_write_op(self):...
    def create_read_op(self):...
    def release_write_op(self, write_op: WriteOp):...
    def release_read_op(self, read_op: ReadOp):...
    def set_omap(self, write_op: WriteOp, keys, values):...
    def operate_write_op(self, write_op: WriteOp, oid, mtime=0, flags=LIBRADOS_OPERATION_NOFLAG):...
    def operate_aio_write_op(self, write_op: WriteOp, oid, oncomplete=None, onsafe=None, mtime=0, flags=LIBRADOS_OPERATION_NOFLAG):...
    def operate_read_op(self, read_op: ReadOp, oid, flag=LIBRADOS_OPERATION_NOFLAG):...
    def operate_aio_read_op(self, read_op: ReadOp, oid, oncomplete=None, onsafe=None, flag=LIBRADOS_OPERATION_NOFLAG):...
    def get_omap_vals(self, read_op: ReadOp, start_after, filter_prefix, max_return):...
    def get_omap_keys(self, read_op: ReadOp, start_after, max_return):...
    def get_omap_vals_by_keys(self, read_op: ReadOp, keys):...
    def remove_omap_keys(self, write_op: WriteOp, keys):...
    def clear_omap(self, write_op: WriteOp):...
    def lock_exclusive(self, key, name, cookie, desc="", duration=None, flags=0):...
    def lock_shared(self, key, name, cookie, tag, desc="", duration=None, flags=0):...
    def unlock(self, key, name, cookie):...
    def set_osdmap_full_try(self):...
    def unset_osdmap_full_try(self):...
    def application_enable(self, app_name, force=False):...
    def application_list(self):...
    def application_metadata_set(self, app_name, key, value):...
    def application_metadata_remove(self, app_name, key):...
    def application_metadata_list(self, app_name):...
    def alignment(self):...

def set_object_locator(func):...
def set_object_namespace(func):...

class Object(object):
    def __init__(self, ioctx: Ioctx, key, locator_key=None, nspace=None):
        self.key = key
        self.ioctx = ioctx
        self.offset = 0
        self.state = "exists"
        self.locator_key = locator_key
        self.nspace = "" if nspace is None else nspace

    def require_object_exists(self):...
    def read(self, length=1024 * 1024):...
    def write(self, string_to_write):...
    def remove(self):...
    def stat(self):...
    def seek(self, position):...
    def get_xattr(self, xattr_name):...
    def get_xattrs(self):...
    def set_xattr(self, xattr_name, xattr_value):...
    def rm_xattr(self, xattr_name):...

MONITOR_LEVELS = ...
